"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const Lint = require("tslint/lib/index");
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithWalker(new JsdocCommentsWalker(sourceFile, this.getOptions()));
    }
}
Rule.metadata = {
    ruleName: "jsdoc-require",
    description: "Requires JSDoc comments for class members, interfaces and functions.",
    rationale: "Making sure that all code elements are well documented improves code" +
        " readability. It also helps with JSDoc generation as well as transpilation" +
        " to compilers like Google's closure.",
    optionsDescription: Lint.Utils.dedent `
              Two arguments may be optionally provided:
            * \`"no-methods"\` excludes JSDoc comments on interface specifications and class methods
            * \`"no-constructors"\` excludes JSDoc comments on class constructors
            * \`"no-properties"\` excludes JSDoc comments on class properties
            * \`"no-functions"\` excludes JSDoc comments on all functions
            * \`"no-protected"\` excludes JSDoc comments on protected elements
            * \`"no-namespace-functions"\` excludes JSDoc comments on namespace function assignments
            * \`"no-private"\` excludes JSDoc comments on private elements
            * \`"no-private-properties"\` excludes private properties from enforcing JSDoc comments.`,
    options: {
        type: "array",
        items: {
            type: "string",
            enum: ["methods", "properties", "functions", "protected", "public",
                "namespace-functions", "no-private-properties"],
        },
        minLength: 0,
        maxLength: 6,
    },
    optionExamples: ["true", '[true, "methods", "protected"]'],
    type: "typescript",
    typescriptOnly: false
};
Rule.FAILURE_STRING_FACTORY = (memberType, memberName) => {
    memberName = memberName == null ? "" : ` '${memberName}'`;
    return `Missing JSDoc element for ${memberType}${memberName}`;
};
exports.Rule = Rule;
class JsdocCommentsWalker extends Lint.RuleWalker {
    visitConstructorDeclaration(node) {
        if (!this.hasOption("no-constructors")) {
            this.validateJsDocComment(node);
        }
        super.visitConstructorDeclaration(node);
    }
    visitExpressionStatement(node) {
        if (!this.hasOption("no-namespace-functions") &&
            node.expression.kind === ts.SyntaxKind.BinaryExpression &&
            node.expression.left.kind === ts.SyntaxKind.PropertyAccessExpression &&
            node.expression.right.kind === ts.SyntaxKind.FunctionExpression) {
            this.validateJsDocComment(node);
        }
        super.visitConstructorDeclaration.call(this, node);
    }
    visitMethodSignature(node) {
        if (!this.hasOption("no-methods")) {
            this.validateJsDocComment(node);
        }
        super.visitMethodSignature(node);
    }
    visitFunctionDeclaration(node) {
        if (!this.hasOption("no-functions")) {
            this.validateJsDocComment(node);
        }
        super.visitFunctionDeclaration(node);
    }
    visitMethodDeclaration(node) {
        if (!this.hasOption("no-methods")) {
            this.validateJsDocComment(node);
        }
        super.visitMethodDeclaration(node);
    }
    visitPropertyDeclaration(node) {
        if (!this.hasOption("no-properties")) {
            this.validateJsDocComment(node);
        }
        super.visitPropertyDeclaration(node);
    }
    validateJsDocComment(node) {
        const hasPrivateModifiers = Lint.hasModifier(node.modifiers, ts.SyntaxKind.PrivateKeyword);
        const hasProtectedModifiers = Lint.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword);
        if ((this.hasOption("no-protected") && hasProtectedModifiers) ||
            (this.hasOption("no-private") && hasPrivateModifiers) ||
            (this.hasOption("no-private-properties") && hasPrivateModifiers &&
                node.kind === ts.SyntaxKind.PropertyDeclaration)) {
            return;
        }
        let comment = this.getJsDocCommentsFromText(node, this.getSourceFile().text);
        if (comment && comment.length) {
            return;
        }
        let memberType;
        switch (node.kind) {
            case ts.SyntaxKind.ExpressionStatement:
                memberType = "namespace function declaration";
                break;
            case ts.SyntaxKind.MethodSignature:
                memberType = "interface declaration";
                break;
            case ts.SyntaxKind.FunctionDeclaration:
                memberType = "function declaration";
                break;
            case ts.SyntaxKind.MethodDeclaration:
                memberType = "class method";
                break;
            case ts.SyntaxKind.PropertyDeclaration:
                memberType = "class property";
                break;
            case ts.SyntaxKind.Constructor:
                memberType = "class constructor";
                break;
            default:
                memberType = "";
        }
        if (hasPrivateModifiers) {
            memberType = "private " + memberType;
        }
        if (hasProtectedModifiers) {
            memberType = "protected " + memberType;
        }
        let memberName;
        node.getChildren().forEach((n) => {
            if (n.kind === ts.SyntaxKind.Identifier) {
                memberName = n.getText();
            }
        });
        const failureString = Rule.FAILURE_STRING_FACTORY(memberType, memberName);
        this.addFailure(this.createFailure(node.getStart(), node.getWidth(), failureString));
    }
    getJsDocCommentsFromText(node, text) {
        const commentRanges = (node.kind === ts.SyntaxKind.Parameter ||
            node.kind === ts.SyntaxKind.TypeParameter ||
            node.kind === ts.SyntaxKind.FunctionExpression ||
            node.kind === ts.SyntaxKind.ArrowFunction) ?
            getCommentRanges(text, node.pos, false).concat(getCommentRanges(text, node.pos, true)) :
            getCommentRanges(text, node.pos, false);
        return commentRanges ? commentRanges.filter(isJsDocComment) : [];
        function isJsDocComment(comment) {
            return text.charCodeAt(comment.pos + 1) === "*".charCodeAt(0) &&
                text.charCodeAt(comment.pos + 2) === "*".charCodeAt(0) &&
                text.charCodeAt(comment.pos + 3) !== "/".charCodeAt(0);
        }
        function isWhiteSpace(ch) {
            return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
        }
        function isWhiteSpaceSingleLine(ch) {
            return ch === 32 ||
                ch === 9 ||
                ch === 11 ||
                ch === 12 ||
                ch === 160 ||
                ch === 133 ||
                ch === 5760 ||
                ch >= 8192 && ch <= 8203 ||
                ch === 8239 ||
                ch === 8287 ||
                ch === 12288 ||
                ch === 65279;
        }
        function isLineBreak(ch) {
            return ch === 10 ||
                ch === 13 ||
                ch === 8232 ||
                ch === 8233;
        }
        function lastOrUndefined(array) {
            if (array.length === 0) {
                return undefined;
            }
            return array[array.length - 1];
        }
        function getCommentRanges(text, pos, trailing) {
            let result;
            let collecting = trailing || pos === 0;
            while (pos < text.length) {
                const ch = text.charCodeAt(pos);
                switch (ch) {
                    case 13:
                        if (text.charCodeAt(pos + 1) === 10) {
                            pos++;
                        }
                    case 10:
                        pos++;
                        if (trailing) {
                            return result;
                        }
                        collecting = true;
                        if (result && result.length) {
                            lastOrUndefined(result).hasTrailingNewLine = true;
                        }
                        continue;
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                        pos++;
                        continue;
                    case 47:
                        let nextChar = text.charCodeAt(pos + 1);
                        let hasTrailingNewLine = false;
                        if (nextChar === 47 || nextChar === 42) {
                            const kind = nextChar === 47 ?
                                ts.SyntaxKind.SingleLineCommentTrivia :
                                ts.SyntaxKind.MultiLineCommentTrivia;
                            const startPos = pos;
                            pos += 2;
                            if (nextChar === 47) {
                                while (pos < text.length) {
                                    if (isLineBreak(text.charCodeAt(pos))) {
                                        hasTrailingNewLine = true;
                                        break;
                                    }
                                    pos++;
                                }
                            }
                            else {
                                while (pos < text.length) {
                                    if (text.charCodeAt(pos) === 42 && text.charCodeAt(pos + 1) === 47) {
                                        pos += 2;
                                        break;
                                    }
                                    pos++;
                                }
                            }
                            if (collecting) {
                                if (!result) {
                                    result = [];
                                }
                                result.push({ pos: startPos, end: pos, hasTrailingNewLine, kind });
                            }
                            continue;
                        }
                        break;
                    default:
                        if (ch > 127 && (isWhiteSpace(ch))) {
                            if (result && result.length && isLineBreak(ch)) {
                                lastOrUndefined(result).hasTrailingNewLine = true;
                            }
                            pos++;
                            continue;
                        }
                        break;
                }
                return result;
            }
            return result;
        }
    }
}
exports.JsdocCommentsWalker = JsdocCommentsWalker;
